### query_ticket

- 算法

  - 查找经过起点站的车次 `sList` 、终点站的车次 `tList`

    有一个为空说明没有符合条件的车次

  - 均非空，两两枚举车次对，有以下要求：

    - `trainID` 相等，因为不允许换乘。

    - 由于要在 `day` 这一天**上车**，计算出对应的火车发站时间 `startDay`，

      则这个 `startDay` 要在 `trainID` 的售卖范围内。

      注意不是 `day` 在范围内。给一个反例：

      > 火车售卖区间 08-01 ~ 08-02，到达 A 站距离出发 3 天，
      >
      > 应该要查到 08-04 的票！

    - 起点站要在终点站的左边。有两种比法：

      比 index  或者 **离开起点站时间要早于到达终点站时间**

  - 符合以上条件就是合法的票了，加入答案序列。



### query_transfer

- 算法

  - 查找经过起点站的车次 `sList` 、终点站的车次 `tList`

    有一个为空说明没有符合条件的车次

  - 均非空，两两枚举车次对。

    考虑这两辆车先后的一次 transfer. 有以下要求：

    -  `trainID` 要**不同**

    - 由于要在 `day` 这一天**上车**，计算出对应的火车发站时间 `startDay1`，

      则这个 `startDay1` 要在**第一辆车**的售卖范围内。

    - 两者的时间条件：第一辆车到达那一天之后，第二辆车必须**存在一天有卖票**

      由于还没开始枚举到哪站，我们最宽估计：至少是 `day` 到达

      所以 `day` 必须有票卖，即 `endSaleDate<day` 直接排除

  - 现在枚举中转站。暴力思路：枚举第一辆车起点站往后的站，第二辆车终点站往前的站。

    考虑这个站作为中转站，则：

    - 两站名字相同。

    - 时间顺序：考虑在 `day1 ` 上第二辆车，则其对应的发站时间必须落在第二辆车销售范围内。

      上第二辆车的时间范围为 [第一辆车到达日，无穷]，因此不用考虑是否会小于第二辆车的开始售卖日，只要关心是否大于结束售卖日。

      最快上第二辆车的时间：第一辆车到达日，对应发站时间 `fastestStartDay2`

      如果它都大于，那其它发站时间肯定更长。

      如果它小等于，说明最快一定能赶上。这时候要看什么时候开始卖，也许太快了人家还没开始卖，要等到开始卖。